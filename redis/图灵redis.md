### redis问题-不可用

- 缓存穿透
  - 概念：访问不存在的缓存
  - 方案：
    - 布隆过滤器判断缓存是否存在
    - 设置null值和较短的过期时间
- 缓存击穿
  - 概念：高并发下缓存过期失效，瞬间访问数据库
  - 方案：
    - 热点数据，设置缓存永不过期
    - 采用分布式锁，缓存失效后只有一个线程更新并写入
- 缓存雪崩
  - 概念：大面的缓存击穿或服务不可用
  - 方案
    - 采用Redis哨兵机制或集群等架构提升可用性
    - 采用和缓存击穿一样的方式
    - 错误缓存数据的过期时间，防止缓存大面积失效

### redis架构
- 单击：只有一台redis
- 主从：一主多从，主redis负责写，从redis负责读
- 哨兵：在主从基础上，增加哨兵机制，来选择主redis，但是还是主redis负责写，从redis负责读
- 集群：多主，16384个hash slot确定往哪台主redis上写

### 主从复制的应用场景
- 防止数据丢失
- 读写分离
- 可用性、扩展性

### 主从复制的方式
- 全量复制？？？
- 增量复制？？？

### redis持久化的方式
- RDB：Redis DataBase 持久化内存数据到磁盘
  - redis主进程Fork一个子进程，定时并且达到出发修改次数时，进行写磁盘，写到RDB文件中
- AOF：Append Only File 持久化修改数据的命令
  - 以 每秒/每个命令./不同步 等方式进行

### RDB和AOF的区别

| 比较内容       | RDB            | AOF            |
| -------------- | -------------- | -------------- |
| 保存内容       | 二进制数据文件 | Redis命令      |
| 数据恢复速度   | 快照恢复速度快 | 命令过多速度慢 |
| 数据恢复完整性 | 可能丢失数据   | 比RDB高        |


### 如何能够最大化保证恢复数据的速度及数据的完整性
混合持久化

### Redis分布式锁的实现
- setnx + expire
  - 如果key不存在 set成功返回1，失败返回0
  - expire防止锁的长期持有或死锁

- set + expire
- 比较删除解锁
  - 删除钱判断是否是加锁的客户端